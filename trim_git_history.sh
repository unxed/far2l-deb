#!/bin/bash

# based on https://stackoverflow.com/a/6815228

# Проверка на наличие аргумента. Ожидается хэш коммита, начиная с которого нужно сохранить историю.
# По умолчанию используется самый последний по времени коммит, т.е. история удаляется полностью.
if [ -z "$1" ]; then
    COMMIT_HASH=$(git rev-parse HEAD)
else
    COMMIT_HASH=$1
fi

# Отключаем сжатие в этом репозитории. Всё равно большая часть хранимых здесь файлов уже сжаты.
git config core.compression 0

# Создание новой временной ветки без родительской истории.
git checkout --orphan temp $COMMIT_HASH

# Создание коммита с сообщением "Truncated history" в этой временной ветке.
git commit -m "Truncated history"

# Перемещение всех коммитов из master на новую временную ветку, начиная с указанного коммита.
git rebase --onto temp $COMMIT_HASH master

# Удаление временной ветки после завершения операции.
git branch -D temp

# Очистка неиспользуемых объектов из базы данных и упаковка оставшихся объектов для оптимизации занимаемого места.
git gc --prune=all

# Переупаковка объектов в .pack файлы. Это уменьшает занимаемое место, удаляет старые .pack файлы
# и может разделить объекты на несколько .pack файлов для больших репозиториев.
# -a: Упаковать все объекты в новый .pack файл. Это удобно, чтобы убедиться, что все объекты упакованы корректно.
# -f: Упаковать объекты даже если они уже были упакованы ранее. Это может быть полезно для переупаковки
#     с учетом новых оптимизаций или алгоритмов.
# -F: Пытается упаковать объекты в несколько .pack файлов. Эта опция полезна для очень крупных репозиториев,
#     чтобы избежать создания слишком больших .pack файлов.
# -d: После упаковки удаляет старые .pack файлы, которые были заменены новыми.
git repack -a -f -F -d

# Принудительное обновление удаленного репозитория изменениями из локального. Требуется осторожность, так как это может перезаписать изменения на удаленной стороне!
git push origin master --force

# Сообщение об успешном завершении операции.
echo "Операция завершена успешно!"
